OSI 7/5 层模型
	"""
	物理层：
　　　　定义特性：机械，电器，功能，过程；
　　　　定义接口标准：双绞线，光纤，同轴电缆；
　　　　相关协议：无；
　　
	数据链路层：
　　　　定义帧的开始结束，封装成帧，差错校验，透明传输（防止误认结束帧而数据断裂）；
　　　　负责尽力的数据帧的传输，错误即丢，不负责丢失重传以及顺序，点到点的mac地址传输；
　　　　相关协议：ATM，PPP，HDLC；
　　
	网络层：
　　　　端到端的包IP寻址传输，负责尽力发送数据包，不负责丢失重传以及顺序，
　　　　相关协议：IPV4，IPV6；
　　
	传输层：流量控制，可靠传输，udp，tcp；
　　
	会话层：控制会话的开始结束，木马防范等；
　　
	表示层：定义数据格式加密等；
　　
	应用层：http，snmp，ftp，telnet；
	"""
	
	
	

三次握手、四次挥手？
	"""
	三次握手
					syn=1 seq=x 
		客户端 ---------------------> 服务端
		
				syn=1 ack=x+1 seq=y 
		客户端 <--------------------- 服务端
				
				    ack=y+1 seq=z 
		客户端 ---------------------> 服务端
	
		客户端发起后发送 syn 以及 seq 
		服务端接收后回复 syn ack 以及 seq 且 ack 的值为 客户端的 seq+1
		客户但接收后回复 ack 以及 seq 且 ack 的值为 服务端的的 seq+1
		
		简单来说就是：
			发起方发起建立链接情趣
			接受方给与确认，提供链接
			发起方建立链接
		
		
		
		即确认机制是 基于上一次对方返回的序号进行+1确认方式 

	四次挥手：
		
					fin=1 ack=z seq=x 
		客户端 --------------------------> 服务端
		
					ack=x+1 seq=z
		客户端 <-------------------------- 服务端
		
					fin=1 ack=x seq=y 
		客户端 <-------------------------- 服务端
				
				    ack=y seq=x
		客户端 --------------------------> 服务端
		
		客户端发起断链申请 发送 fin ack 以及 seq
		服务端回应 ack seq 且 ack为 客户端的seq+1 以及 seq 为 客户端的 ack
		服务端发起断链会话 发送 fin ack 以及 seq 且 ack 为 客户端的 seq 
		客户端接收断链 发送 ack seq 且 ack 为 服务端的 seq 以及 seq 为服务端的 ack
		
		确认机制较为复杂懒得记了。记住大体流程就行了。
		
		简单来说就是：
			发起方发起断开链接申请
			接收方回复收到断开申请
			接收方发起断开链接
			发起方接受断开链接
		
	"""

什么是C/S和B/S架构
	"""
	#C/S架构：
		client端与server端的服务架构
		
	#B/S架构：
		隶属于C/S架构，Broswer端（网页端）与server端；
		优点：统一了所有应用的入口，方便、轻量级
	"""
	
	
TCP和UDP区别？
	"""
	#TCP协议：面向连接
	   - 通信之前先三次握手
	   - 断开之前先四次握手
	   - 必须先启动服务端，再启动客户端-->连接服务端
	   - 安全、可靠、面向连接(不会丢包)
	#UDP协议：无连接
	   - 传输速度快
	   - 先启动哪一端都可以
	   - 不面向连接，不能保证数据的完整性(如：QQ聊天)
	"""

ARP协议？
	"""
	#ARP(地址解析协议) 其主要用作将IP地址翻译为以太网的MAC地址

	#在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。

	#在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。


	#所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。
	#ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。
	"""
	
DNS解析？

Http和Https？

进程、线程、协程区别？
	"""
	进程：
		cpu 执行的基本单位
		一个软件可以多个进程
		进程之间数据隔离 
	
	线程：
		CUP工作的最小单位，
		线程依附于进程，一个进程可以存在多个线程 
		可以同享进程的资源
	
	协程：
		协程实际上并不是真实存在的，其实是人为创建的
		本质上协程就是微线程，将线程进行划片调整执行顺序
		单纯的协程并不是提高并发效率 
			协程主要用于 IO 操作的时候进行代码顺序的切换，
				在代码中进行转换执行顺序从而实现 非阻塞 进而加快执行效率
			如果在 计算性任务 操作中会导致效率的降低 
	"""

GIL锁
	"""
	全局解释器锁，保证同一时刻一个进程只有一个线程被CPU调度。
	数据安全：自己加锁。
	"""

进程如何进程共享？
	"""
	- queque
	- pipe 
	- manager
	"""

什么是粘包？
	"""
	粘包：数据粘在一起，
	
	主要因为：
		接收方不知道消息之间的界限，不知道一次性提取多少字节的数据造成的
		数据量比较小，时间间隔比较短，就合并成了一个包，这是底层的一个优化算法（Nagle算法）
	"""















