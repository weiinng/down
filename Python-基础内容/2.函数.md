——————————————————————————----——————————————————————————————————————————————
定义函数：
def 函数名(): 
      代码

——————————————————————————----——————————————————————————————————————————————
在定义的函数内修改全局变量
a=100,b=0
def t():
     global a
     a=200
     global b
     b=a
可以将修改后的全局变量a的值赋给全局变量b

——————————————————————————----——————————————————————————————————————————————
函数的返回值如果是多个数据  默认是元祖
def divid(a,b):
      return a,b
result=divid(5,2)
print(result)
结果为(5,2)

——————————————————————————----——————————————————————————————————————————————
return后面可以是元组，列表、字典等，只要是能够存储多个数据的类型，就可以一次性返回多个数据（重点）
def a():
     return  {"num1":1,"num2":2,"num3":3}

def get_my_info():
	high=178
	weight=100
	age=18
	return high,weight,age

my_high,my_weight,my_age=get_my_info()
print(my_high)结果为178

——————————————————————————----——————————————————————————————————————————————
>. 缺省参数
>调用函数时，缺省参数的值如果没有传入，则取默认值。
>下例会打印默认的age，如果age没有被传入：
>def q(a,age=35):
>     print(age)
>q(9,5)
>结果为5
>q(9)
>结果为35

带有默认值的参数一定要位于参数列表的最后面

——————————————————————————----——————————————————————————————————————————————
不定长参数
有时可能需要一个函数能处理比当初声明时更多的参数, 这些参数叫做不定长参数，声明时不会命名。
基本语法如下：
加了星号（*）的变量args会存放所有未命名的变量参数，args为元组
而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典.
def fun(a,b,*args,**kwargs):
     print(a)
     print(b)
     print(args)
     for key,value in kwargs.items():
          print("key=%s"%value)
fun(1,2,3,4,5,m=6,n=7,p=8)
结果为
1 2 (3,4,5) key=6 key=7 key=8

c=(3,4,5)
d={"m":6,"n":7,"p":8}
fun(1,2,*c,**d)结果和上面一样

——————————————————————————----——————————————————————————————————————————————
缺省参数在*args后面**kwargs前面

——————————————————————————----——————————————————————————————————————————————
匿名函数：
用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤
例如：
sum=lambda arg1,arg2:arg1+arg2
print("Value of total :",sum(10,20))
结果为：Value of total:30

f=lambda x : print(x)
f(1)
结果为1

——————————————————————————----——————————————————————————————————————————————
列表推导式
请用列表推导式写出一段Python代码，实现分组一个list里面的元素，比如[1,2,3,...100]
list=[x,for x in range(1,101)]
列表推到式  只能在列表里推导   前面可以也是个列表  循环 思想要开阔
一行代码实现九九乘法表：
print('\n'.join([' '.join(['%d*%d=%d'%(x,y,x*y) for x in range(1,1+y)]) for y in range(1,10) ]))

给字典排序：
stus=[
{"name":"zhangsan","age":18},
{"name":"zhangsan","age":17},
{"name":"zhangsan","age":19}
]
按age排序：
stus.sort(key=lambda x:x['age'],reverse=True)

——————————————————————————————————————————————
将list 变成[[1,2,3],[4,5,6]....]
b=[a[x:x+3] for x in range(0,len(a),3)]
[x:x+3]是切片 左闭右开区间  表示a列表里有x,x+1,x+2  
0，len(list),3  三个数字代表的意义也是切片


——————————————————————————————————————————————
查看函数文档说明用help
def add2num():
    '''文档说明'''
    a,b=10,20
    print(a+b)

add2num()
print(help(add2num))
输出结果为:文档说明
这个只能是用多行注释注释你要要解释的内容并且只能放在最上面 否则没有  


——————————————————————————————————————————————

在形参中默认有值的参数  一定要位于参数列表的最后面
缺省参数在*args后面**kwargs前面

——————————————————————————————————————————————
加了*的变量args会存放所有未命名的变量参数，args为元祖
尔加了**的变量kwargs会存放参数 kwars为key=value的形式

def func(a,b,*args,**kwargs):
    print(a)
    print(b)
    print(args)
    print(kwargs)
    for x in kwargs.keys():
        print(x)

c=(1,2,3,4,5)
func(1,2,3,4,5,c,m=1,n=2)

1
2
(3, 4, 5, (1, 2, 3, 4, 5))
{'m': 1, 'n': 2}
m
n

——————————————————————————————————————————————
**kargs中的参数  前面的参数名不能与形参重名  否则报错
在有不定长函数中 如上给a和b赋值时不能a=1,b=2这样赋值 只能写1,2  否则报错
遍历kwargs时 后要加items() 否则报错

——————————————————————————————————————————————
拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常
除了对元组拆包之外，还可以对列表、字典等拆包
字典的拆包取出来的是键名
a,b=[1,2]   a=1,b=2
a,b={'name':'12','age':1}   a='name',b='age'

——————————————————————————————————————————————
所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变
可变类型有： 列表、字典、集合
不可变类型有： 数字、字符串、元组