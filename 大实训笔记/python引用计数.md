###引用计数

**引用计数+1的情况：**

​	1、对象被创建时，例如 mark="帅哥"

​	2、对象被copy引用时，例如 mark2=mark，此时mark引用计数+1

​	3、对象被作为参数，传入到一个函数中时

​	4、对象作为一个子元素，存储到容器中时，例如 list=[mark,mark2]

**引用计数-1的情况：**

​	1、对象别名被显式销毁，例如 del mark

​	2、对象引用被赋予新的对象，例如mark2=mark3，此时mark引用计数-1

​	3、一个函数离开他的作用域，例如函数执行完成，它的引用参数的引用计数-1

​	4、对象所在容器被销毁，或者从容器中删除。

##### 引用计数机制优点：

​	实时性，只要没有了引用就释放资源。

##### 引用计数机制缺点：

​	1、维护引用计数需要消耗一定的资源

​	2、循环引用时，无法回收。正是因为这个原因，才需要通过标记-清理和分代回收来辅助引用计数。

**标记删除时通过l两个容器来完成的：死亡容器、存活容器。**

标记删除第一步：对执行删除操作后的每个引用-1，此时c的引用为0，d的引用为0，把他们都放到死亡容器内。把那些引用仍然大于0的放到存活容器内。标记删除第二步：遍历存活容器，查看是否有的存活容器引用了死亡容器内的对象，如果有就把该对象(注意是对象，比如0x7f94bb602f80，不是对象的引用)从死亡容器内取出，放到存活容器内。由于c、d都没有对象引用他们了，所以经过这一步骤，他们还是在死亡组。标记删除第三部：将死亡组所有对象删除。这样就完成了对从c、d的删除。

**分代回收：** 

​	1、新创建的对象做为0代

​	2、每执行一个【标记-删除】，存活的对象代数就+1

​	3、代数越高的对象（存活越持久的对象）进行【标记-删除】的时间间隔就越长。这个间隔，称阀值。

**弱引用：**

​	weakref   #微克瑞福

​	弱引用的主要作用就是减少循环引用，减少内存中不必要的对象存在的数量。 

​	weakref模块的ref(obj[,callback])来创建一个弱引用，obj是你想弱引用的对象，callback是一个可选的函数。

**触发垃圾回收呢，有三种情况：**

　　1、达到了垃圾回收的阈(yu)值，Python虚拟机自动执行

　　2、手动调用gc.collect()

　　3、Python虚拟机退出的时候

**__del__方法**

del语句操作某个对象的时候, 并不是直接将该对象在内存中删除, 而是将该对象的引用计数-1

python(Cpython)中对象会包含一个引用计数。__del__方法只有当引用计数为0时才会执行。 

```
class f:
    def __del__(self):
        print(id(self))
a = [f(),f()]
b = a
del a # 还有b在引用，所以没有执行__del__
del b
2414194009984
2414194010824
```

当存在循环引用时，执行del函数，对应的__del__方法将不会执行。 

这时可以使用垃圾回收接口–GC，来回收和显示这些不能删除的对象。 

```
import gc 
gc.collect() #克莱克特
Remove <class '__main__.Child'>  id 2408580851920
Remove <class '__main__.Child'>  id 2408580852144
Remove <class '__main__.Parent'>  id 2408580852872
```

