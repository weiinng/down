# [项目部署上线流程](https://www.cnblogs.com/songjianan/p/9002036.html)

在项目部署上线的时候，会发生各种各样的错误。若按照步骤进行部署，错误便会大大的减少。步骤如下：

1、 需要知道有几台服务器，以及服务器环境搭建的情况。

2、 服务器是否在同一个机房

​     a) 在同一个机房，通过内网进行通信  --  速度快

​     b) 不在同一个机房，通过外网通信   --  速度慢

3、 服务器的硬件以及操作系统

  如果应用程序对计算要求高，则部署在cpu核数较多的服务器。若果应用程序对内存要求较高，则部署在内存较多的服务器上。

 应该合理的利用计算机的资源。

​     a) 硬件

1. 内存  --  多大？
2. CPU  --  几核？  
3. 硬盘 --  多大？  
4. IO读写速度 -- 机械硬盘还是SSD（固态硬盘）？

​    b) 操作系统

1. Windows？
2. Linux？
3. 32？ 64？

4、 做最后的功能测试

5、 SVN打tag   

 与Maven打war包是不一样的，tag约定只读，不能修改其中的项目。项目都是基于tag去发布的。tag就是用于项目发布的。

6、 打包程序（Maven）maven打成war包。

7、 数据库脚本以及初始数据

数据库脚本及数据也是程序的一部分，不能忘记。

8、 编写发布文档

编写发布文档很重要，在项目发布的时候，总会出现各种各样的问题，所以需要写发布文档，根据文档一步一步操作去发布项目。

a) 要将发布的内容以及发布步骤都写下来

b) 回滚的机制

1. 程序的回滚 ：项目由新版本到上一个版本的回滚。
2. 数据的回滚 ：对数据库的变更可进行数据回滚。
3. 系统间的调用关系的回滚

9、 实施发布

需要打包的程序

​    1.数据库脚本及数据

​    2.nginx的配置文件，配置文件是通用的。无论在Windows还是在Linux中。

​    3.项目中的静态资源文件上传目录也打包。打包成tar.gz

项目打包

 maven命令 

​      项目-->Run As -->Maven build...

​     Goals中输入命令 clean package （先清除再打包，清除的是target下的内容 。要跳过测试skip tests打勾）可打成war包。





三元运算 作用：节约代码量 便于阅读

全局解释器锁  ： cpython  自带的全局解释器锁，保证线程安全用的，多线程操作一个系统资源，比如说多线程操作一个系统文件的时候，就必须上全局解释器锁，否则就会造成混乱，多线程适配多核资源，不加锁资源会被随意篡改，线程不安全。

继承 ： 多继承  ，单继承   括号里写object  如果不写object 就变成元类了 

内置函数 ：  help() 和 dir()      dir()可以知道类里有哪些方法     help() 针对内置的方法

猴子补丁 :    建立实例之后，就不能再修改类的属性和方法，monkey catch 在实例运行的时候进行动态更改

pass  和 continue 的区别，

闭包  装饰器语法糖@   限速(限制访问速率)     授权权限认证   在不改变原有方法，增加新的功能，

lambda 是不想声明def  就像完成业务，关系，功能的情况下，完成某些操作，结合四大高阶函数 ，  

递归  ，使用在无限分类和遍历文件夹  ，递归终极用法就是递归的对象是未知的，用在未知情况下

生成器， 迭代器   ： 意义 就是迭代一个可迭代对象用的，使用性能好， range 底层是迭代器，   xrange是循环    性能更高，节约内存， 迭代器缺点：迭代到最后一个就会报错， 底层原理 ：就是for循环计算长度 ，如果长度为1亿，那就先得计算1亿的长度，再进行迭代

生成器本身就是特殊的迭代器，生成器能保存变量的状态，使用yield下一次本身保存上一次状态， 在scrapy 框架中，数据库入库时 yield保存状态

参数传递机制 ： 有引用传递 和值传递 一个元素  深拷贝拷贝的是值， 浅拷贝拷贝的是引用地址，如果是深拷贝操作，不会改变原拷贝对象因为拷贝的值， 

浅拷贝改变原有对象的值因为改的是引用，当把可变类型作为参数传递，传递的是引用，如果是不可变类型，是值传递，是深拷贝。tuple 是不可变类型 ，所以传递的是值，是深拷贝。

元类，可以理解为基类，为继承，加跨域，加json  在json(dumps) 里面日期格式会报错， 可以在基类里先把日期转换成字符串格式，基类可以提高复用性。

内存管理机制：引用计数 和垃圾回收，  声明一个变量，计1 ，复制一份计2，对变量的引用做计数，如果删除就是垃圾回收。

python2 和 python 3   python3.6 dict底层变有序的了 

数组：是线性结构，有序的数据结构，list，tuple，dict都是有序的，set是无序的，list在python里面是没有定长长度的，list不需要声明长度，无限的append就行，这就是python对数组的改造。但在java语言、C语言，定义一个数组的时候必需要定义数组的长度。所以导致内存有差异， python的list的性能要比数组低。原因是要事先分配好足够的内存空间，每一次存储需要打出两倍的内存来存储数据， 数组而是规定好了内存，再超出就不行了。

数组只能存单一类型的数据，比如说规定了int，只能存int， 而 list 可以存储多种数据类型。







