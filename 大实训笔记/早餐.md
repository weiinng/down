# 解释一下Python中的三元运算

```
[on true] if [expression] else [on false]
```

如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句

```
a,b=2,3
min=a if a<b else b
min
```

## GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。

# 解释一下Python中的继承

当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。

继承能让我们重新使用代码，也能更容易的创建和维护应用。Python支持如下种类的继承：

单继承：一个类继承自单个基类 多继承：一个类继承自多个基类 多级继承：一个类继承自单个基类，后者则继承自另一个基类 分层继承：多个类继承自单个基类 混合继承：两种或多种类型继承的混合

# 解释Python中的help()和dir()函数

Help()函数是一个内置函数，用于查看函数或模块用途的详细说明：

```
import copy
help(copy.copy)
```

Dir()函数也是Python内置函数，dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。

```
dir(copy.copy)
```

# 什么是猴子补丁？

在运行期间动态修改一个类或模块。

```
class A:
    def func(self):
        print("Hi")
def monkey(self):
    print("Hi, monkey")
m.A.func = monkey
a = m.A()
a.func()
```

# 请解释使用*args和\**kwargs的含义

当我们不知道向函数传递多少参数时，比如我们向传递一个列表或元组，我们就使用*args。

```
>>> def func(*args):
    for i in args:
        print(i)  
>>> func(3,2,1,4,7)
```

在我们不知道该传递多少关键字参数时，使用**kwargs来收集关键字参数。

```
>>> def func(**kwargs):
    for i in kwargs:
        print(i,kwargs[i])
>>> func(a=1,b=2,c=7)
```

# 什么是负索引？

负索引和正索引不同，它是从右边开始检索。

它也能用于列表中的切片：

```
mylist=[0,1,2,3,4,5,6,7,8]
mylist[-3]
mylist[-6:-1]
```

# 解释Python中的join()和split()函数

Join()能让我们将指定字符添加至字符串中。

Split()能让我们用指定字符分割字符串。

# 怎么移除一个字符串中的前导空格？

字符串中的前导空格就是出现在字符串中第一个非空格字符前的空格。我们使用方法Istrip()可以将它从字符串中移除。

```
'   Ayushi '.lstrip()
```

可以看到，该字符串既有前导字符，也有后缀字符，调用Istrip()去除了前导空格。如果我们想去除后缀空格，就用rstrip()方法。

```
'   Ayushi '.rstrip()
```

# Python中的pass语句是什么？

在用Python写代码时，有时可能还没想好函数怎么写，只写了函数声明，但为了保证语法正确，必须输入一些东西，在这种情况下，我们会使用pass语句。

```
def func(*args):
    pass
```

同样，break语句能让我们跳出循环。

```
for i in range(7):
    if i==3: break
```

最后，continue语句能让我们跳到下个循环。

```
for i in range(7):
    if i==3: continue
    print(i)
```

# Python中的闭包是什么？

当一个嵌套函数在其外部区域引用了一个值时，该嵌套函数就是一个闭包。其意义就是会记录这个值。

```
def A(x):
    def B():
        print(x)
    return B
```

# 谈一谈Python的装饰器（decorator）

装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。

装饰器其实就是一个闭包，把一个函数当做参数然后返回一个替代版函数

# 解释一下Python中的逻辑运算符

Python中有3个逻辑运算符：and，or，not

# Python支持什么数据类型？

1. Numbers（数字）——用于保存数值
2. Strings（字符串）——字符串是一个字符序列。我们用单引号或双引号来声明字符串。
3. Lists（列表）——列表就是一些值的有序集合，我们用方括号声明列表。
4. Tuples（元组）——元组和列表一样，也是一些值的有序集合，区别是元组是不可变的，意味着我们无法改变元组内的值。
5. Dictionary（字典）——字典是一种数据结构，含有键值对。我们用大括号声明字典

# 什么是切片？

切片是Python中的一种方法，能让我们只检索列表、元素或字符串的一部分。在切片时，我们使用切片操作符[]。

```
(1,2,3,4,5)[2:4]
```

# Python中的不可变集合（frozenset）是什么？

首先，我们讨论一下什么是集合。集合就是一系列数据项的合集，不存在任何副本。另外，集合是无序的。

这就意味着我们无法索引它。

不过，集合是可变的。而不可变集合却不可变，这意味着我们无法改变它的值，从而也使其无法作为字典的键值。

```
myset=frozenset([1,3,2,2])
myset
```

# 解释lambda表达式，什么时候会用到它？

如果我们需要一个只有单一表达式的函数，我们可以匿名定义它。拉姆达表达式通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。

```
(lambda a,b:a if a>b else b)(3,3.5)
```

实现斐波那契数列

```
fib = lambda n : n if n <= 2 else fib(n-1)+fib(n-2)
```

# 什么是递归？

在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归。但为了避免出现死循环，必须要有一个结束条件

```
def facto(n):
    if n==1: return 1
    return n*facto(n-1)
facto(4)
```

# 什么是生成器？

生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。

# 什么是迭代器？

迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。我们使用inter()函数创建迭代器。

# 请说说生成器和迭代器之间的区别?

在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。 生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。

# Python中的yield用法

yield简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次(或n 次)调用跳转至该函 次)调用跳转至该函数。

# 解释Python的参数传递机制

Python使用按引用传递（pass-by-reference）将参数传递到函数中。如果你改变一个函数内的参数，会影响到函数的调用。这是Python的默认操作。不过，如果我们传递字面参数，比如字符串、数字或元组，它们是按值传递，这是因为它们是不可变的。

python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。

# 如何在Python中创建自己的包？

Python中创建包是比较方便的，只需要在当前目录建立一个文件夹，文件夹中包含一个**init**.py文件和若干个模块文件，其中**init**.py可以是一个空文件，但还是建议将包中所有需要导出的变量放到**all**中，这样可以确保包的接口清晰明了，易于使用。

# 元类

元类是类的类对象，换言之类是元类的实例，Python中默认的元类为type，可以通过自定义元类的方式实现对类创建的控制。

```
class Base:
    a = 1
    b = 2

    print('class defined')

    def __new__(cls, *args, **kwargs):
        print(cls.__name__, 'class instance created')
        return super().__new__(cls)

    def __init__(self):
        print(type(self).__name__, 'class instance inited')

    def hello(self):
        pass


b = Base()
```

当调用print(type(b))，得到，可知b是Base类的实例。Python是纯面向对象语言，因此类也是对象，当调用print(type(Base))时得到，可知类Base是type的实例，type就是Python中的原生元类，用来控制、生成类这个对象。 一般地，在定义类时，默认的此类的元类是type，因此，如果我们想控制类的创建，需要将类的元类指为我们自定义的元类，这个自定义的元类需要继承type元类。





-------------------------------------------------------------------------------------------------

# 在Python中是如何管理内存的

Python有一个私有堆空间来保存所有的对象和数据结构。作为开发者，我们无法访问它，是解释器在管理它。但是有了核心API后，我们可以访问一些工具。Python内存管理器控制内存分配。

另外，内置垃圾回收器会回收使用所有的未使用内存，所以使其适用于堆空间。

一、垃圾回收：python不像C++，Java等语言一样，他们可以不用事先声明变量类型而直接对变量进行赋值。对Python语言来讲，对象的类型和内存都是在运行时确定的。这也是为什么我们称Python语言为动态类型的原因(这里我们把动态类型可以简单的归结为对变量内存地址的分配是在运行时自动判断变量类型并对变量进行赋值)。

二、引用计数：Python采用了类似Windows内核对象一样的方式来对内存进行管理。每一个对象，都维护这一个对指向该对对象的引用的计数。当变量被绑定在一个对象上的时候，该变量的引用计数就是1，(还有另外一些情况也会导致变量引用计数的增加),系统会自动维护这些标签，并定时扫描，当某标签的引用计数变为0的时候，该对就会被回收。

1 对象存储

在Python中万物皆对象

不存在基本数据类型，`0, 1.2, True, False, "abc"`等，这些全都是对象

所有对象, 都会在内存中开辟一块空间进行存储

2.1 会根据不同的类型以及内容, 开辟不同的空间大小进行存储 2.2 返回该空间的地址给外界接收(称为"引用"), 用于后续对这个对象的操作 2.3 可通过 id() 函数获取内存地址(10进制) 2.4 通过 hex() 函数可以查看对应的16进制地址

```
class Person:
    pass

p = Person()
print(p)
print(id(p))
print(hex(id(p)))


>>>> 打印结果

<__main__.Person object at 0x107030470>
4412605552
0x107030470
```

对于整数和短小的字符, Python会进行缓存; 不会创建多个相同对象

此时, 被多次赋值, 只会有多份引用

```
num1 = 2
num2 = 2
print(id(num1), id(num2))

>>>> 打印结果

4366584464 4366584464
```

容器对象, 存储的其他对象, 仅仅是其他对象的引用, 并不是其他对象本身

4.1 比如字典, 列表, 元组这些"容器对象" 4.2 全局变量是由一个大字典进行引用 4.3 可通过 global() 查看

2 对象回收 2.1 引用计数器 2.1.1概念

一个对象, 会记录着自身被引用的个数 每增加一个引用, 这个对象的引用计数会自动+1 每减少一个引用, 这个对象的引用计数会自动-1

引用计数+1场景

```
1、对象被创建
    p1 = Person()
2、对象被引用
    p2 = p1
3、对象被作为参数，传入到一个函数中
    log(p1)
    这里注意会+2, 因为内部有两个属性引用着这个参数
4、对象作为一个元素，存储在容器中
    l = [p1]
```

引用计数-1场景

```
1、对象的别名被显式销毁
    del p1
2、对象的别名被赋予新的对象
    p1 = 123
3、一个对象离开它的作用域
    一个函数执行完毕时
    内部的局部变量关联的对象, 它的引用计数就会-1
4、对象所在的容器被销毁，或从容器中删除对象
```

查看引用计数

```
import sys

class Person:
    pass

p1 = Person() # 1

print(sys.getrefcount(p1)) # 2

p2 = p1 # 2

print(sys.getrefcount(p1)) # 3

del p2 # 1
print(sys.getrefcount(p1)) # 2

del p1
# print(sys.getrefcount(p1)) #error，因为上一行代码执行类p1对象已经销毁

>>>> 打印结果

2
3
2
```

循环引用

```
# 循环引用
class Person:
    pass

class Dog:
    pass

p = Person() 
d = Dog()   

p.pet = d 
d.master = p
```

对象间互相引用，导致对象不能通过引用计数器进行销毁

手动触发垃圾回收，挥手循环引用

```
import objgraph
import gc

class Person:
    pass

class Dog:
    pass

p = Person()
d = Dog()

p.pet = d
d.master = p


del p
del d

gc.collect() #手动触发垃圾回收

print(objgraph.count("Person"))
print(objgraph.count("Dog"))

>>>> 打印结果
0
0
```









==========================================================================

# 深拷贝和浅拷贝之间的区别是什么？

深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝

```
import copy
b=copy.deepcopy(a)
```

![avatar](https://v3u.cn/book/img/deepcopy.jpg)

而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝

```
b=copy.copy(a)
```

![img](https://v3u.cn/book/img/copy.jpg)













==========================================================================

# 列表和元组之间的区别是？

二者的主要区别是列表是可变的，而元组是不可变的

不同点一：不可变 VS 可变 两种类型除了字面上的区别(括号与方括号)之外，最重要的一点是tuple是不可变类型，大小固定，而 list 是可变类型、数据可以动态变化，这种差异使得两者提供的方法、应用场景、性能上都有很大的区别。

不同点二：同构 VS 异构 tuple 用于存储异构(heterogeneous)数据，当做没有字段名的记录来用，比如用 tuple 来记录一个人的身高、体重、年龄。

person = ("zhangsan", 20, 180, 80) 比如记录坐标上的某个点

point = (x, y) 而列表一般用于存储同构数据(homogenous)，同构数据就是具有相同意义的数据，比如下面的都是字符串类型

["zhangsan", "Lisi", "wangwu"] 再比如 list 存放的多条用户记录

[("zhangsan", 20, 180, 80), ("wangwu", 20, 180, 80)] 数据库操作中查询出来的记录就是由元组构成的列表结构。

因为 tuple 作为没有名字的记录来使用在某些场景有一定的局限性，所以又有了一个 namedtuple 类型的存在，namedtuple 可以指定字段名，用来当做一种轻量级的类来使用。

# 列表和字典的区别

列表是序列，可以理解为数据结构中的数组，字典可以理解为数据结构中的hashmap

他俩都可以作为集合来存储数据

从差异特征上来说

1. list是有序的，dict是无需的
2. list通过索引访问，dict使用key访问
3. list随着数量的正常增长要想查找元素的时间复杂度为O(n), dict不随数量而增长而变化，时间负责都为O(1)
4. dict的占用内存稍比list大，会在1.5倍左右

特征决定用途：

list一般可作为队列、堆栈使用，而dict一般作为聚合统计或者快速使用特征访问等

# 可变与不可变

可变类型（mutable）：列表，字典

不可变类型（unmutable）：数字，字符串，元组

这里的可变不可变，是指内存中的那块内容（value）是否可以被改变。如果是不可变类型，在对对象本身操作的时候，必须在内存中新申请一块区域(因为老区域#不可变#)。如果是可变类型，对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的address会保持不变，但区域会变长或者变短。

copy.copy() 浅拷贝

copy.deepcopy() 深拷贝

浅拷贝是新创建了一个跟原对象一样的类型，但是其内容是对原对象元素的引用。这个拷贝的对象本身是新的，但内容不是。拷贝序列类型对象（列表\元组）时，默认是浅拷贝。

# 列表底层实现

实现细节 python中的列表的英文名是list，因此很容易和其它语言(C++, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。

从细节上看，Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数过分配，所以并不是每次操作都需要改变数组的大小。但是，也因为这个原因添加或取出元素的平摊复杂度较低。

不幸的是，在普通链表上“代价很小”的其它一些操作在Python中计算复杂度相对过高。

利用 list.insert方法在任意位置插入一个元素——复杂度O(N) 利用 list.delete或del删除一个元素——复杂度O(N)

### 列表推导

要习惯用列表推导，因为这更加高效和简短，涉及的语法元素少。在大型的程序中，这意味着更少的错误，代码也更容易阅读。

```
>>>[i for i in range(10) if i % 2 == 0]
    [0, 2, 4, 6, 8]
```

1.使用enumerate.在循环使用序列时，这个内置函数可以方便的获取其索引：

```
for i, element in enumerate(['one', 'two', 'three']):
    print(i, element)
```

# 字典底层实现

字典是python中最通用的数据结构之一。dict可以将一组唯一的键映射到相应的值。

字典推导式

```
squares = {number: number**2 for number in range(10)}
print(squares)
```

在遍历字典元素时，有一点需要特别注意。字典里的keys(), values()和items()3个方法的返回值不再是列表，而是视图对象（view objects）。

keys(): 返回dict_keys对象，可以查看字典所有键

values():返回dict_values对象，可以查看字典的所有值

items():返回dict_items对象，可以查看字典所有的{key, value}二元元组。

CPython使用伪随机探测(pseudo-random probing)的散列表(hash table)作为字典的底层数据结构。由于这个实现细节，只有可哈希的对象才能作为字典的键。

Python中所有不可变的内置类型都是可哈希的。可变类型（如列表，字典和集合）就是不可哈希的，因此不能作为字典的键。

字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).

还有一点很重要，在复制和遍历字典的操作中，最坏的复杂度中的n是字典曾经达到的最大元素数目，而不是当前的元素数目。换句话说，如果一个字典曾经元素个数很多，后来又大大减小了，那么遍历这个字典可能会花费相当长的事件。因此在某些情况下，如果需要频繁的遍历某个词典，那么最好创建一个新的字典对象，而不是仅在旧字典中删除元素。

字典的缺点和替代方案

使用字典的常见陷阱就是，它并不会按照键的添加顺序来保存元素的顺序。在某些情况下，字典的键是连续的，对应的散列值也是连续值（例如整数），那么由于字典的内部实现，元

素的实现可能和添加的顺序相同：

```
keys = {num: None for num in range(5)}.keys()
print(keys)
```

如果我们需要保存添加顺序怎么办？python 标准库的collections模块提供了名为OrderedDicr的有序字典

# 集合

集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构极其有用。

python的内置集合类型有两种：

set(): 一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。 frozenset(): 一种不可变的、可哈希的、无序的集合，其元素是唯一的，不可变的哈希对象。

set里的元素必须是唯一的，不可变的。但是set是可变的，所以set作为set的元素会报错。

实现细节

CPython中集合和字典非常相似。事实上，集合被实现为带有空值的字典，只有键才是实际的集合元素。此外，集合还利用这种没有值的映射做了其它的优化。

由于这一点，可以快速的向集合中添加元素、删除元素、检查元素是否存在。平均时间复杂度为O(1),最坏的事件复杂度是O(n)。









==========================================================================

# python2和python3的区别

print语句被python3废弃，只能使用print函数

Python3中字符串是Unicode (utf-8)编码，支持中文做标识符。

python2中是ASCII编码，需要更改字符集才能正常支持中文，所以在.py文件中会看到#-- coding: UTF-8 --

异常处理 Python2中try:...except Exception, e:...，在Python3中改为了try:...except Exception as e:...

Python3中不再使用xrange方法，只有range方法。

range在Python2中返回列表，而在Python3中返回range可迭代对象。

在Python2中有两个不等运算符!=和<>，在Python3中去掉了<>，只有!=符号表示不等

在Python2中双反引号`可以替代repr函数，在Python3中去掉了双反引号的表是方法，只能用repr`方法。

StringIO模块现在被合并到新的io模组内。new, md5, gopherlib等模块被删除。

httplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib被合并到http包内。

取消了exec语句，只剩下exec()函数。

在Python2中long是比int取值范围更大的整数，Python3中取消了long类型，int的取值范围扩大到之前的long类型范围。

列表推导 不再支持[n for n in a,b]语法，改为[n for n in (a,b)]或[n for n in [a,b]]

python 2 中通过input输入的类型是int，只有通过raw_input()输入的类型才是str。

python 3中通过input输入的类型都是str，去掉了row_input()方法。

## python3.6中dict有序

有序是指遍历时的输出顺序与输入顺序相同

## 关于哈希表

1. 散列表概念 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
2. 哈希函数 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。 （相关：是不是可以这样理解，数组可以通过下标进行访问，时间复杂度是O(1)，对于不连续存储的数据结构，如果知道下标也可以直接进行访问，所以可以通过哈希函数将key映射成数组下标，进行访问）
3. 冲突 不同的key经过hash函数运行后得到相同的值，产生冲突；
4. 冲突解决方式
5. 开放寻址：线性探测、二次探测、伪随机数序列（python的dict解决冲突用的这个，具体的策略没有看太明白）
6. 再哈希法：将哈希值再哈希，然后存储；
7. 链地址法：hash过后值相同的存储在链表里；
8. 公共溢出区

python实现dict无序到有序：

1. 原先的内存布局entries为哈希表，表中直接存储PyDictKeyEntry（hash、key、value），也就是说当当前位置为空的时候存的是（0， null， null）浪费了大量内存；

1. python3.6: indices充当哈希表，存储的entries的index，使用index去访问存有PyDictKeyEntry的数组

## python3 dict性能优化

节省存储空间：将存储PyDictKeyEntry的稀疏数组更改为存储int的稀疏数组； 之前的dict_entry是稀疏表，经压缩后在密集表上循环，使用更少的内存； 调整大小更快，并且触及更少的内存。 目前，每一个散列/键/值条目在一个过程中被移动或复制调整。 在新的布局中，只有索引是更新。 大多数情况下，散列/键/值条目从不移动（除了偶尔交换填充删除留下的空洞）。

## range和xrange区别

range返回的是一个包含所有元素的列表，xrange返回的是一个生成器，生成器是一个可迭代对象，在对生成器进行迭代时，元素是逐个被创建的。而列表需要根据列表长度而开辟出相应的内存空间用来遍历，一般来看，在对大序列进行迭代的时候，因为xrange的特性，所以它会比较节约内存。









==========================================================================

# Python中 进程 线程 协程 (多任务概念/重点)

## 进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。

一个进程具有:就绪，运行，中断，僵死，结束等状态(不同操作系统不一样)。

生命周期：

用户编写代码(代码本身是以进程运行的)

启动程序，进入进程“就绪”状态

操作系统调度资源，做“程序切换”，使得进程进入“运行”状态

结束/中断

特性

每个程序，本身首先是一个进程

运行中每个进程都拥有自己的地址空间、内存、数据栈及其它资源。

操作系统本身自动管理着所有的进程(不需要用户代码干涉)，并为这些进程合理分配可以执行时间。

进程可以通过派生新的进程来执行其它任务，不过每个进程还是都拥有自己的内存和数据栈等。

进程间可以通讯(发消息和数据)，采用 进程间通信(IPC) 方式。

说明

多个进程可以在不同的 CPU 上运行，互不干扰

同一个CPU上，可以运行多个进程，由操作系统来自动分配时间片

由于进程间资源不能共享，需要进程间通信，来发送数据，接受消息等

多进程，也称为“并行”。

### 进程间通信

进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的。

### 进程队列queue

不同于线程queue，进程queue的生成是用multiprocessing模块生成的。

在生成子进程的时候，会将代码拷贝到子进程中执行一遍，及子进程拥有和主进程内容一样的不同的名称空间。

multiprocess.Queue 是跨进程通信队列

常用方法

```
q.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。
q.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.
q.get_nowait():同q.get(False)
q.put_nowait():同q.put(False)
q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。
q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。
q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样
```

### 管道pipe

管道就是管道，就像生活中的管道，两头都能进能出

默认管道是全双工的，如果创建管道的时候映射成False，左边只能用于接收，右边只能用于发送，类似于单行道

```
import multiprocessing

def foo(sk):
    sk.send('hello world')
    print(sk.recv())

if __name__ == '__main__':
    conn1,conn2=multiprocessing.Pipe()    #开辟两个口，都是能进能出，括号中如果False即单向通信
    p=multiprocessing.Process(target=foo,args=(conn1,))  #子进程使用sock口，调用foo函数
    p.start()
    print(conn2.recv())  #主进程使用conn口接收
    conn2.send('hi son') #主进程使用conn口发送
```

常用方法

```
conn1.recv():接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError。
conn1.send(obj):通过连接发送对象。obj是与序列化兼容的任意对象
注意：send()和recv()方法使用pickle模块对对象进行序列化
```

### 共享数据manage

Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。

注：进程间通信应该尽量避免使用共享数据的方式

### 进程池

开多进程是为了并发，通常有几个cpu核心就开几个进程，但是进程开多了会影响效率，主要体现在切换的开销，所以引入进程池限制进程的数量。

进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。

## 线程

线程，是在进程中执行的代码。

一个进程下可以运行多个线程，这些线程之间共享主进程内申请的操作系统资源。

在一个进程中启动多个线程的时候，每个线程按照顺序执行。现在的操作系统中，也支持线程抢占，也就是说其它等待运行的线程，可以通过优先级，信号等方式，将运行的线程挂起，自己先运行。

使用

用户编写包含线程的程序(每个程序本身都是一个进程)

操作系统“程序切换”进入当前进程

当前进程包含了线程，则启动线程

多个线程，则按照顺序执行，除非抢占

特性

线程，必须在一个存在的进程中启动运行

线程使用进程获得的系统资源，不会像进程那样需要申请CPU等资源

线程无法给予公平执行时间，它可以被其他线程抢占，而进程按照操作系统的设定分配执行时间

每个进程中，都可以启动很多个线程

说明

多线程，也被称为”并发“执行。

### 线程池

系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。

线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。

此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。

### 多线程通信

#### 共享变量

创建全局变量，多个线程公用一个全局变量，方便简单。但是坏处就是共享变量容易出现数据竞争，不是线程安全的，解决方法就是使用互斥锁。

#### 变量共享引申出线程同步问题

如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。

#### 队列

线程间使用队列进行通信，因为队列所有方法都是线程安全的，所以不会出现线程竞争资源的情况

Queue.Queue 是进程内非阻塞队列

## 进程和线程的区别

一个进程中的各个线程与主进程共享相同的资源，与进程间互相独立相比，线程之间信息共享和通信更加容易(都在进程中，并且共享内存等)。

线程一般以并发执行，正是由于这种并发和数据共享机制，使多任务间的协作成为可能。

进程一般以并行执行，这种并行能使得程序能同时在多个CPU上运行;

区别于多个线程只能在进程申请到的的“时间片”内运行(一个CPU内的进程，启动了多个线程，线程调度共享这个进程的可执行时间片)，进程可以真正实现程序的“同时”运行(多个CPU同时运行)。

进程和线程的常用应用场景

一般来说,在Python中编写并发程序的经验:

计算密集型任务使用多进程

IO密集型(如:网络通讯)任务使用多线程，较少使用多进程.

这是由于 IO操作需要独占资源，比如:

网络通讯(微观上每次只有一个人说话，宏观上看起来像同时聊天)每次只能有一个人说话

文件读写同时只能有一个程序操作(如果两个程序同时给同一个文件写入 'a', 'b'，那么到底写入文件的哪个呢?)

都需要控制资源每次只能有一个程序在使用，在多线程中，由主进程申请IO资源，多线程逐个执行，哪怕抢占了，也是逐个运行，感觉上“多线程”并发执行了。

如果多进程，除非一个进程结束，否则另外一个完全不能用，显然多进程就“浪费”资源了。

当然如上解释可能还不足够立即理解问题所在，让我们通过不断的实操来体验其中的“门道”。

## 协程

协程: 协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行.

协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用，如果是cpu密集型，推荐多进程+协程的方式。

协程，又称微线程。

说明

协程的主要特色是:

协程间是协同调度的，这使得并发量数万以上的时候，协程的性能是远远高于线程。

注意这里也是“并发”，不是“并行”。

常用库：greenlet gevent

协程优点：

　　1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级

　　2. 单线程内就可以实现并发的效果，最大限度地利用cpu

协程缺点：

　　1.协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程

　　2.协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程

## python中的协程

一个协程是一个函数/子程序（可以认为函数和子程序是指一个东西）。这个函数可以暂停执行， 把执行权让给 YieldInstruction，等 YieldInstruction 执行完成后，这个函数可以继续执行。 这个函数可以多次这样的暂停与继续。

注：这里的 YieldInstruction, 我们其实也可以简单理解为函数。

协程可以在“卡住”的时候可以干其它事情。

```
async def long_task():
...     print('long task started')
...     await asyncio.sleep(1)
...     print('long task finished')
...
>>> loop.create_task(long_task())
<Task pending coro=<long_task() running at <stdin>:1>>
>>> loop.create_task(job1())                                                                                                                                                                                                                            >>>>> loop.create_task(job1())
<Task pending coro=<job1() running at <stdin>:1>>
>>>
>>> try:
...     loop.run_forever()
... except KeyboardInterrupt:
...     pass
...
long task started
job1 started...
job1 paused
hello world
job1 resumed
job1 finished
long task finished
```

从这段程序的输出可以看出，程序本来是在执行 long task 协程，但由于 long task 要 await sleep 1 秒，于是 long task 自动暂停了，hello_world 协程自动开始执行， hello world 执行完之后，long task 继续执行。

协程有两种定义的方法， 其中使用生成器形式定义的协程叫做 generator-based coroutine, 通过 async/await 声明的协程叫做 native coroutine，两者底层实现都是生成器。接着， 我们阐述了协程的概念，从概念和例子出发，讲了协程和生成器最主要的特征：可以暂停执行和恢复执行。

### 协程异常处理

使用协程的时候一定加了很多的异常,但百密而一疏,总是会有想象不到的异常发生,这个时候为了不让程序整体崩溃应该使用协程的额外异常处理方法,这个方法会去执行绑定的回调函数.

```
g_dict=dict{}
g = gevent.spawn(self._g_fetcher, feed_name)   # 创建协程
g_dict[feed_name] = [g,False]
g.link_exception(self._link_exception_callback)  # 给该协程添加出现处理不了的异常时候的回调函数
def _link_exception_callback(self, g):
    # 可能遇到无法修复的错误，需要修改代码 todo 报警
    # 可以在这个函数里面做一些错误异常的打印,或者文件的关闭,连接的关闭.
    self.terminated_flag = True # 停止整个程序 让 supervior重启
    logger.info("_link_exception_callback {0} {1}".format(g, g.exception))
    self._kill_sleep_gevent()   # 轮询结束休眠的协程

def _kill_sleep_gevent(self):
    for i,is_sleep in g_dict.items():
        if is_sleep[1] == "True":
            gevent.kill(is_sleep[0])
```

### greenlet框架实现协程（封装yield的基础库）

greenlet机制的主要思想是：生成器函数或者协程函数中的yield语句挂起函数的执行，直到稍后使用next()或send()操作进行恢复为止。可以使用一个调度器循环在一组生成器函数之间协作多个任务。greentlet是python中实现我们所谓的"Coroutine(协程)"的一个基础库。

### 基于greenlet框架的高级库gevent模块

gevent是第三方库，通过greenlet实现协程，其基本思想是：

当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。