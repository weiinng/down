## **百钱百鸡**

### **案例描述**

中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱百鸡问题”：一只公鸡值五钱，一只母鸡值三钱，三只小鸡值一钱，现在要用百钱买百鸡，请问公鸡、母鸡、小鸡各多少只？

### **案例分析**

如果用一百钱只买一种鸡，那么，公鸡最多20只，母鸡最多33只，小鸡最多300只。但题目要求买100只，所以小鸡的数量在0~100之间，公鸡数量在0~20之间，母鸡数量在0~33之间。我们把公鸡，母鸡和小鸡的数量分别设为cock、hen、chicken，通过上述分析可知：

（1）0<=cock<=20；

（2）0<=hen<=33；

（3）0<=chicken<=100；

（4）cock+hen+chicken=100；

（5）5*cock+3*hen+chicken/3=100。

与此同时，可知母鸡、小鸡和公鸡的数量相互限制，这里可以使用三层循环嵌套来解决此问题。在实现案例之前，先来学习完成程序需要的知识。

### **必备知识**

#### **循环的嵌套**

有时为了解决一个较为复杂的问题，需要在一个循环中再定义一个循环，这样的方式被称作循环嵌套。在C语言中，while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套。

### **案例实现**

#### **1.案例设计**

（1）先定义三个整型变量分别用来存储公鸡、母鸡和小鸡；

（2）第一层for循环控制公鸡的数量，第二层for循环控制母鸡的数量，第三层for循环控制小鸡的数量；

（3）根据这三层循环我们可以得到很多种方案，但是其中有很多是不符合条件的，我们要把合理的方案筛选出来，即把满足“cock+hen+chicken=100”和“5*cock+3*hen+chicken/3=100”的方案输出。

#### **2.完整代码；**

```go
 #include <stdio.h>
 int main()
 {
     int cock,hen,chicken;
     for(cock = 0; cock <= 20; cock++)  					//控制公鸡的数量
      	for (hen = 0; hen <= 33; hen++)  				//控制母鸡的数量
     		     for (chicken = 0; chicken <= 100; chicken++) 	//控制小鸡的数量
     		     {
     			     if((5*cock+3*hen+chicken/3.0 == 100)&&(cock+hen+chicken == 100))
     			printf("cock=%2d,hen=%2d,chicken=%2d\n",cock,hen,chicken);
                    //将满足条件的方案，直接输出到屏幕上
     		     }
     return 0;
}
```

代码第9行把条件五改成了“5*cock+3*hen+chicken/3.0=100”，这是因为C语言中两个整数相除得到结果仍为整数，“/”两边如果有一个数是float类型时，所得结果为float型，在以后编程时要注意对“/”两边数据类型进行处理。

**多学一招：算法优化**

上述算法需要尝试21*34*101=72114次，为了提高效率，可以对算法进行优化。当公鸡和母鸡的数量确定后，小鸡数量固定为100-cock-hen，此时约束条件只剩条件五了，代码如下：

```go
 #include <stdio.h>
 int main()
 {
     int cock,hen,chicken;
     for(cock = 0; cock <= 20; cock++)
     	   for (hen = 0; hen <= 33; hen++)
     	   {
     		   chicken = 100 - cock - hen;
    		   if(5*cock+3*hen+chicken/3.0 == 100)
     		   printf("cock=%2d,hen=%2d,chicken=%2d\n",cock,hen,chicken);
         }
     return 0;
 }
```

此算法只需尝试21*34=714次，大大缩短运算时间。

## **回文素数**

### **案例描述**

若整数i从左向右读与从右向左读是相同的数，且i为素数，此时称其为回文素数。所谓素数是指只能由1和它本身整除的整数。

对于偶数位的整数，只有11是回文素数。也就是说，除了11以外，所有的2位整数都不是回文素数。所有的4位整数、6位整数、8位整数中也不存在回文素数。但是三位回文素数有很多，比如：101、131、151、181、191、313等。本案例要求通过编程求出所有小于1000的回文素数。

### **案例分析**

因为要对所有1000以内的整数进行判断，所以此处适合用循环结构语句；又因为要判断是否为素数以及判断是否为回文素数，所以一定会用到选择结构语句。此案例综合了本章这两个重要的知识点，请灵活运用学过的知识解决此案例。

### **案例实现**

#### **1.案例设计**

（1）先采用穷举法对1000以内所有整数进行遍历，判断其是否为素数。判断一个数是否为素数的关键在于，判定整数能否被1和它自身之外的其他整数所整除，如果都不能整除，则此数为素数；

（2）如果此数为素数，则继续判断此数是两位数还是三位数；

（3）如果为两位数，则判断其十位和个位是否相同，如果相同则说明此数为回文素数；如果是三位数，则判断其百位和个位是否相同，如果相同则说明此数为回文素数；

（4）最后将所有小于1000的回文素数打印输出到屏幕上即可。

#### **2.完整代码**

```go
 #include <stdio.h>
 
 int main()
 {
     int flag;                                
     //定义整型变量flag用来记录是否为素数，1代表是，0代表不是
     int n;
     int i;
     for (n = 10; n < 1000; n++)
     {
         for (i = 2; i < n; i++)                 
         {
             flag = 1;                        //flag默认为1
             if (n % i == 0)
             {
                 flag = 0;                    //如果不符合素数要求，则把flag置为0
                 break;                       //并跳出循环
             }
         }
 
         if(flag == 1)                        //判断是否是素数
         {    
                       
             if (n / 100 == 0)                //判断是否是两位数
             {
                 if (n / 10 == n % 10)        //判断十位和各位是否相同
                 {
                     printf("%4d", n);
                 }
             }
             else
             {
                 if (n / 100 == n % 10)       //判断百位和个位是否相同
                 {
                     printf("%4d", n);
                 }
             }
         }
     }
     printf("\n");
     return 0;
 }
```

## **听说过自守数么**

### **案例描述**

如果某个数的平方的末尾几位等于该数自身，那么就称这个数为自守数。例如，0和1的平方的个位数仍然是0和1，所以0和1是自守数，称为平凡自守数。很显然，5和6是一位自守数，因为5×5=25，6×6=36。而25和76是两位自守数，因为25×25=625，76×76=5776，当然还有三位自守数，四位自守数等等，在此不再一一介绍。

自守数有一个特性，以它为后几位的两个数相乘，乘积的后几位仍是这个自守数。因为5是自守数，所以以5为个位数的两个数相乘，[乘积](http://baike.baidu.com/view/563968.htm)的个位仍然是5；76是自守数，所以以76为后两位数的两个数相乘，其结果的后两位仍是76，如176×576=101376。

案例要求编程求出0~10000内的所有自守数，并依次输出到屏幕上。

### **案例分析**

根据自守数的定义可知，案例的关键是知道当前所求数的位数。由于数字范围控制在了10000以内，所以直接求出此数的平方后再截取最后相应的位数，和原数比较，判断是否相同即可。

### **案例实现**

#### **1.案例设计**

（1）用for循环遍历1~10000之间的所有整数；

（2）求出当前循环中此数的平方和此数的位数；

（3）通过对此数的平方取余求出此数的尾数；

（4）判断尾数是否和此数相等，如果相等则为自守数，将此数输出到屏幕上。

#### **2.完整代码**

```go
 #include <stdio.h>
 #include <math.h>
 int main()
 {
     int i, a, k, m;               //此数为i
     for(i = 1; i < 10000; i++)  //在1~10000的范围内依次检验
     {
         a = i;                      //把i的值赋给a
         a *= a;                     //求出a的平方即i的平方
         k = log10(i) + 1;         //求出i的位数k
         for(m = 1; k; k--) 
             m *= 10;
         a %= m;                     //通过取余求出尾数
         if(a == i)                 //判断i的平方的尾数是否等于i
             printf("%d\n", i);   //输出所有自守数
     }
     return 0;
 }
```

## **最大值和最小值**

### **案例描述**

最值问题可谓是经典中的经典了，说它是每个程序员都该掌握的知识一点也不为过。本案例要求先输入数组的大小和各个数组元素，然后求出数组中的最大值和最小值以及它们所在的位置，最后把它们依次输出到屏幕上。

### **案例分析**

本案例是应用一维数组的典型案例。C语言中规定，只能逐个引用数组中的元素，而不能引用整个数组。所以在对数组元素进行判断时，只能通过循环对数组元素逐个引用，通过判断每一个元素值的大小，找出其中最大和最小的元素。

为了更好地完成此案例，请先认真学习一维数组的相关知识。

### **必备知识**

#### **1.** **一维数组的定义与初始化**

一维数组也称向量，它用以组织具有一维顺序关系的一组同类型数据。在C语言中，一维数组的定义方式如下所示：

数据类型  数组名[常量表达式];

在上述语法格式中，类型说明符表示数组中所有元素的类型，常量表达式指的是数组的长度，也就是数组中存放元素的个数。例如： 

int array[5];

上述代码定义了一个数组，编译器为数组分配存储空间。其中，int是数组的类型，array是数组的名称，方括号中的5是数组的长度。值得注意的是：数组占据的内存空间是连续的，这样，很容易计算数组占据的内存大小和每个元素对应的内存首地址。例如对上例来说，其占据的内存大小为：5*sizeof(int)。

完成数组的定义后，编译器根据数组定义语句中提供的数据类型和数组长度给数组变量分配适当的内存空间。这时，如果想使用数组操作数据，还需要对数组进行初始化。数组初始化元素值的常见方式有三种，具体如下：

（1）直接对数组中的所有元素赋初值，示例代码如下：

int i[5]={1,2,3,4,5};

上述代码定义了一个长度为5的数组i，数组中元素的值依次为1、2、3、4、5。

（2）只对数组中的一部分元素赋值，示例代码如下：

int i[5]={1,2,3};

在上述代码中，定义了一个int类型的数组，但在初始化时，只对数组中的前三个元素进行了赋值，其它元素的值会被默认设置为0。

（3）对数组全部元素赋值，但不指定长度，示例代码如下：

int i[]={1,2,3,4};

在上述代码中，数组i中的元素有4个，系统会根据赋值号右边初始值列表中给出的初值个数自动设置数组的长度。因此，数组i的长度为4。

**注意：**

1、数组的下标是用方括号括起来的，而不是圆括号。

2、数据类型不仅可以是int、float、char等基本类型，也可以是后续章节将要介绍的指针、结构体等类型。

3、数组名的命名规则与变量名的命名规则相同。

4、数组定义中，常量表达式的值可以是符号常量，示例如下：

int a[N];      //假设预编译命令#define N 4, 下标是符号常量

#### **2.** **一维数组的引用**

在程序中，经常需要访问数组中的一些元素，因为数组名的本质是存放该数组在内存中的地址的常量，所以无法进行任何计算，这时可以通过数组名和下标来引用数组中的元素。一维数组元素的引用方式如下所示：

数组名[下标];

在上述方式中，下标指的是数组元素的位置，数组元素的下标是从0开始的。例如，引用数组x中第三个元素的方式为：x[2]。

**注意：**

数组的下标都有一个范围，即“0~[数组长度-1]”，假设数组的长度为6，其下标范围为0～5。当访问数组中的元素时，下标不能超出这个范围，否则程序会报错。

### **案例实现**

#### **1.案例设计**

（1）先输入数组的大小；

（2）利用for循环依次输入数组中的各个元素；

（3）分别求出数组元素中的最大值和最小值，并输出到屏幕上。

#### **2.完整代码**

 ```go
 #include <stdio.h>
 int main()
 {
     int a[50];                                        	//定义数组存放元素
     int MAX, MIN;                                     	//定义最大值和最小值变量
     int i, n;               
     int j = 0; 
     int k = 0;
     printf("Please input the size of array:\n");
     scanf("%d", &n);                                  	//输入数组的元素个数
     printf("Please input the elements of the array one by one:\n");
     for (i = 0; i < n; i++)                           	//依次输入数组中的元素
         scanf("%d", &a[i]);
     MIN = a[0];                                       	//数组首元素默认为最小值
     for (i = 1; i < n; i++)                           	//找出数组元素中的最小值
     {    if (a[i] < MIN)                              	//如果有比MIN小的元素
         {
             MIN = a[i];                               	//就把此元素赋值给MIN
             j = i + 1;                                	//将存储最小值的位置赋给j
         }   
     }
     MAX = a[0];                                       	//数组首元素默认为最大值
     for (i = 1; i < n; i++)                           	//找出数组元素中的最大值
     {
         if (a[i] > MAX)                               	//如果有比MAX大的元素
         {
             MAX = a[i];                                	//就把此元素赋值给MAX
             k = i + 1;                                	//将存储最大值的位置赋给k
         }
     }
     printf("The position of the MIN is:%d\n", j);   //输出最小值所在的位置
     printf("The MIN is:%d\n", MIN);
     printf("The position of MAX is:%d\n", k);       //输出最大值所在的位置
     printf("The MAX is:%d\n", MAX);
     return 0;
 }
 ```

## 到底有多少单词

### **案例描述**

要求编程求出一句话中到底有多少单词。首先在屏幕上输入一句话，每个单词之间用一个空格隔开，要求第一个字符和最后一个字符都不能为空格；然后统计出这句话的单词数量，并把结果输出到屏幕上。

### **案例分析**

在程序中一句话可用一串字符表示，输入一串字符需要用到刚刚学过的gets()函数；一句话中单词的数量可以根据获取的字符串中空格的数量确定。综上，本案例的代码应实现以下功能：

（1）使用字符数组变量接收gets()函数获取的字符串；

（2）计算字符数组中的空格数量，推算出此句话中的单词数量；

（3）将统计结果输出。

### **案例实现**

#### **1.案例设计**

（1）首先使用gets()函数将输入的字符串保存在str字符数组中；

（2）然后使用if语句判断用户输入的第一个字符是否为结束符：如果是，则要给出“这句话没有单词”的提示；如果不是，说明字符串正常，开始执行else语句里的代码；

（3）采用for循环遍历字符数组中的每个字符，如果遇到结束符，立即结束循环；如果没有遇到结束符，则判断字符是否为空格。如果是，则把单词数量加1；反之不做任何操作，继续进行循环，判断下一个字符；

（4）最后把总单词数输出到屏幕上。

#### **2.完整代码**

```go
 #include <stdio.h>
 int main()
 {
 	char str[50];			       //定义保存字符串的数组
 	int i, count=1;			       //count表示单词的个数
 	char blank;			  	       //表示空格
 	printf ("Please input a sentence:\n");
 	gets(str);				       //输入字符串
 	if(str[0]=='\0')     	       //判断如果字符串为空的情况
 		printf("No words!\n");
 	else
 	{
 		for(i=0;str[i]!='\0';i++) //循环判断每一个字符
 		{
 			blank=str[i];	        //得到数组中的字符元素
 			if(blank==' ')		   //判断是不是空格
 				count++;		   //如果是则加1
 		}
 		printf("There are %d words in this sentence.\n",count);
 	}
 	return 0;
 }
```









## 猜宝游戏**

### **案例描述**

学生时代的生活虽然单一，但也有许多小游戏贯穿其中，给平淡的校园生活带来一丝欢乐，猜硬币就是这些游戏之一。某个课间，甲和乙一起玩猜硬币的游戏：初始时，甲的左手握着一枚硬币，游戏开始后，甲进行有限次或真或假的交换，最后由乙来猜测这两只手中是否有硬币。

本案例要求编写程序，实现游戏过程。

### **案例分析**

由于该案例比较主观，并且甲的手法和乙的眼力都能影响游戏的结果，因此本案例的目的在于模拟游戏过程。

因为游戏要执行有限次，所以需要首先确定交换进行的次数，通过循环执行每次交换；又因为每次交换是真是假并不确定，所以至少需要实现两个交换函数，一个函数真正地实现两个手中硬币的交换，另一个只需表面完成交换。而每次是否真正地交换硬币也是随机的，因此使用随机数发生器来决定每次选择执行的函数。 

本案例中将涉及到指针的相关使用方式，下面先来学习这些知识。

### **必备知识**

#### **1．** **指针作为函数参数**

在C语言中，实参和形参之间的数据传递是单向的值传递，即只能由实参传递给形参，而不能由形参传递给实参。这与C语言中内存的分配方式有关。当发生函数调用时，系统会使用形参对应的实参为形参赋值，此时的形参以及该函数中的变量都存放在函数调用过程中系统在栈区开辟的空间里，栈区随着函数的调用而被分配，随着函数的结束而被释放，在此过程中，栈区对主调函数不可见，因此主调函数并不能读取栈中形参的数据。若要将栈中的数据传递给主调函数，只能用关键字“return”来实现。

但并非所有从主调函数传入被调函数的数据都是不需要改变的。在第四章学习函数时曾讲到过返回值，利用返回值可以将在被调函数中修改的数据返回给主调函数，但是C语言中返回值只能返回一个数据，往往不能达到要求；函数中也曾学到过全局变量，但是这种方式违背模块化程序设计的原则，与函数的思想背道而驰。

本节将学习一种新的方法，即使用指针变量作为函数的形参，通过传递地址的方式，使形参和实参都指向主调函数中数据所在地址，从而使被调函数可以对主调函数中的数据进行操作。

#### **2．** **指针的交换**

根据指针可以获得变量的地址，也可以得到变量的信息，所以指针交换包含两个方面，一是指针指向交换，二是指针所指地址中存储数据的改变。