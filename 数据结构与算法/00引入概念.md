# 算法效率衡量

## 执行时间反应算法效率

结论：实现算法程序的执行时间可以反映出算法的效率，即算法的优劣。



## 单靠时间值绝对可信吗？

**单纯依靠运行时间来比较算法的优劣并不一定是客观准确的！**

程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反映在程序的执行时间上。那么如何才能客观的一个算法的优劣呢。

## 时间复杂度与“大O记法”

我们假定计算机执行算法每一个基本操作的时间都是一个固定的时间单位，那么有多少基本操作就代表花多少时间单位。算法对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即话费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境而客观的反应算法的时间效率：

对于算法的时间效率，我们可以用“大O记法”来表示。

**“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数，使得对于充分大的n中油f(n)<c*g(n),就说函数g是f的一个渐近函数（忽略常数）,记为f(n) = O(g(n)).也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g约束，亦即函数f与函数g的特征相似。**

**时间复杂度：假设存在函数g使得算法A处理规模为n的问题示例所用时间为T(n) = O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度T(n)。**

## 如何理解“大O记法”

**对于算法进行特别具体的细致分析虽然很好，但是在实践中的价值有限，对于算法的时间性质和空间性质，最总要的是其数量级和趋势，这些是分析算法效率的主要部分，而计量法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n²和100n²属于同一个量级，如果两个算法处理想同样规模实例的代价分别为两个函数，就认为他们的效率差不多，都是n²级别的。**

## 最坏时间复杂度

分析算法时，存在几种可能的考虑：

- 算法完成工作最少需要多少基本操作，即最优时间复杂度。
- 算法完成工作最少需要多少基本操作，即最坏时间复杂度。
- 算法完成工作最少需要多少基本操作，即平均时间复杂度。

对于最优时间复杂度，其价值不大，因为他没有提供什么有用的信息，其反应的知识最乐观最理想的情况，没有参考价值。

对于最坏时间复杂度，提供了一种保证，表名算法在此种程度的基本操作中一定能完成工作。

对于平均时间复杂度，是对算法的一个全面评价，因此他完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每一个计算都能在这基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。

因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。

## 时间复杂度的几条基本计算规则

1. 基本操作，即只有常数项，认为其时间复杂度O(1)
2. 顺序结构，时间复杂度按加减法进行计算。
3. 循环结构，时间复杂度按乘法进行计算。
4. 分支结构，时间复杂度取最大值。
5. 判断一个算法效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。
6. 在没有特殊说明时，我们所分析的算法的时间复杂度指的都是最坏时间复杂度。

# 常见时间复杂度













# Python内置类型性能分析

> 用对数据结构是一个程序员应用的基本技能，这篇整理一下python中基本的抽象数据类型的一下特征，主要是增删改查方面的性能。

## list内置操作的时间复杂度

> python的列表内部实现是数组（具体实现要看解析器, [CPython的实现](https://link.jianshu.com/?t=http://python.jobbole.com/82549/) ），因此就有组数的特点。超过容量会增加更多的容量，set, get 是O(1)，但del, insert, in的性能是O(n)。具体的看下表，'n'是容器中当前的元素数， 'k'需要操作的元素个数

| **Operation**                                                | **Average Case** | **Amortized Worst Case** |
| ------------------------------------------------------------ | ---------------- | ------------------------ |
| Copy                                                         | O(n)             | O(n)                     |
| Append[1]                                                    | O(1)             | O(1)                     |
| Insert                                                       | O(n)             | O(n)                     |
| Get Item                                                     | O(1)             | O(1)                     |
| Set Item                                                     | O(1)             | O(1)                     |
| Delete Item                                                  | O(n)             | O(n)                     |
| Iteration                                                    | O(n)             | O(n)                     |
| Get Slice                                                    | O(k)             | O(k)                     |
| Del Slice                                                    | O(n)             | O(n)                     |
| Set Slice                                                    | O(k+n)           | O(k+n)                   |
| Extend[1]                                                    | O(k)             | O(k)                     |
| [Sort](https://link.jianshu.com/?t=http://svn.python.org/projects/python/trunk/Objects/listsort.txt) | O(n log n)       | O(n log n)               |
| Multiply                                                     | O(nk)            | O(nk)                    |
| x in s                                                       | O(n)             |                          |
| min(s), max(s)                                               | O(n)             |                          |
| Get Length                                                   | O(1)             | O(1)                     |

## dict内置操作的时间复杂度

> 关于字典需要了解的是hash函数和哈希桶。一个好的hash函数使到哈希桶中的值只有一个，若多个key hash到了同一个哈希桶中，称之为哈希冲突。查找值时，会先定位到哈希桶中，再遍历hash桶。[更详细的信息请点这里](https://link.jianshu.com/?t=http://python.jobbole.com/85040/)。在hash基本没有冲突的情况下get, set, delete, in方面都是O(1)。

| **Operation** | **Average Case** | **Amortized Worst Case** |
| ------------- | ---------------- | ------------------------ |
| Copy[2]       | O(n)             | O(n)                     |
| Get Item      | O(1)             | O(n)                     |
| Set Item[1]   | O(1)             | O(n)                     |
| Delete Item   | O(1)             | O(n)                     |
| x in s        | O(1)             | O(n)                     |
| Iteration[2]  | O(n)             | O(n)                     |

## set内置操作的时间复杂度

> 内部实现是dict的。在in操作上是O(1), 这一点比list要强。

| **Operation**                     | **Average case**      | **Worst Case**                                |
| --------------------------------- | --------------------- | --------------------------------------------- |
| x in s                            | O(1)                  | O(n)                                          |
| Union s\|t                        | O(len(s)+len(t))      |                                               |
| Intersection s&t                  | O(min(len(s), len(t)) | O(len(s) * len(t))                            |
| Multiple intersection s1&s2&..&sn |                       | (n-1)*O(l) where l is max(len(s1),..,len(sn)) |
| Difference s-t                    | O(len(s))             |                                               |
| s.difference_update(t)            | O(len(t))             |                                               |
| Symmetric Difference s^t          | O(len(s))             | O(len(s) * len(t))                            |
| s.symmetric_difference_update(t)  | O(len(t))             | O(len(t) * len(s))                            |

## timeit模块

timeit模块可以用来测试一小段Python代码执行速度。

```python
class timeit.Timer(stmt='pass',steup='pass',timer=<timer function>)
```

Timer是测量小段代码执行速度的类。

stmt参数是要测试代码的代码语句（statment）；

setup参数是运行代码时需要的设置。

timer参数是一个定时器函数，与平台无关。

```python
timeit.Timer.timeit(number=1000000)
```

Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。

方法返回执行diamante的平均耗时，一个float类型的秒数。

## list的操作测试

```python
li = []
li.append()
li.inster()
```

# 数据结构

> 我们如何使用Python中的类型来保存一个班的学生信息？如果想要快速的通过学生姓名来获取其信息呢？

**实际上当我们在思考这个问题的时候，我们已经用到了数据结构。列表和字典都可以存储一个班的学生信息，但是想要在一个列表获取一名学生的信息时，就要遍历整个列表，其时间复杂度为O(n)，而使用字典存储时，可将学生姓名作为字典的键，学生信息作为值，进行查询时不需要遍历可以快速获取到学生信息，其时间复杂度为O(1)。**

**为了解决这个问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，name数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。**

**在上面的问题中我们可以选择Python中的列表或者字典来存储学生信息，列表和字典就是Python内建帮我们封装好的两种数据结构。**

```python
#列表和字典是对基本数据存储的一种组织方式。Python中的列表字典元祖set是python封装的高级数据结构，
[
    ("zhangsan",24,"beigin"),
    ("zhangsan",24,"beigin"),
    ("zhangsan",24,"beigin"),
]

#如果我要查询一个列表里面的元祖
for stu in stus:
    if stu(0) =="zhangsan":
        pass

[
    {
        "name":'zhangsan',
        "age":23,
        "homtown":"beijin"
    },
]



{
    "zhangsan":{
        "age":23,
        "homtown":"beijing"
    }

}

#通过字典的key
stus['zhangsan']
```

**数据保存类型不一样，再去找学生信息他的算法也就是不一样的，在做开发的时候数据和算法之间是分不开的，这种数据的组织方式我们叫他数据结构！是列表的方式放在一起还是字典一个放在键值对。**

## 概念

数据是一个抽象的概念，将其进行分类后得到程序设计语言的基本类型。

比如：int、float、char等。

数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。

Python给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫做Python的内置数据结构，比如列表、元祖、字典。而有些数据组织方式，Python系统里面没有直接进行定义，需要我们自己去定义实现这种组织方式，这些数据组织方式被称为Python的拓展数据结构，比如栈、队列等。



## 算法与数据结构的区别

数据结构只是静态的描述了数据元素之间的关系。

高效的程序需要在数据结构的基础上设计和选择算法。

**程序 = 数据结构 + 算法**

**总结：算法时为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。**

## 抽象数据类型(Abstract Data Type)

抽象数据类型（ADT）的含义是指一个数学模型及定义在数学模型上的一组操作，即把数据类型和数据类型上的运算捆绑在一起，进行封装。引入抽象数据类型的目的是吧数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使他们相互独立。

我们常用的数据运算有五种：

- 插入
- 删除
- 修改
- 查找
- 排序

```python
class Stus(object):
	
  def adds(self)
	def pop:
  def sort:
  def modify:
  
```

