## 1.MVC框架

MVC的核心思想：**解耦** 

MVC框架里面的三个模块：

- M：Model模型，和数据库进行交互。
- V：View视图，产生HTML页面。
- C：Controller控制器，接收请求，进行处理，与M和V进行交互，返回应答。

## 2.MVT

- M：Model模型。和MVC中的M功能相同，和数据库进行交互。
- V：View视图。和MVC中C功能相同，接收请求，进行处理，与M和T进行交互，返回应答。
- T：Template,模板。和MVC中V功能相同，产生HTML页面。

## 3.ORM

ORM 可以通过类和对象去操作他对应的表，不需要sql语句。

```
Object:对象 - 类
Mapping:映射
Relations:关系，关系数据库中的表
```

## 4.F对象

作用：用于类属性之间的比较。

解释F：之前我们的查询都是对一个值进行比较，而F对象适用于跟一个 属性之间进行比较。

使用之前需要导入：

```python
from django.db.models import F
```

例：查询阅读量大于评论量图书的信息。

```python
使用F把表内字段 包起来就行了。
BookInfo.objects.filter(bread__gt = F( "bcomment" ))
```

例：查询图书阅读量大于2倍评论量的图书信息。

```python
直接在后面写 * 2 就OK
BookInfo.objects.filter(bread__gt = F( "bcomment" )*2)
```

## 5.Q对象

**作用：用于查询是条件之间的逻辑。and or not ,可以对Q对象进行 &|~ 操作。**

使用之前需要先导入：

```python
from django.db.models import Q
```

| **Q**  | **所查询的对象需要被Q()包含** |
| ------ | ----------------------------- |
| **\|** | **逻辑或**                    |
| **&**  | **和逻辑与**                  |
| **~**  | **逻辑非**                    |

例：查询id大于3且阅读量大于30的图书信息。

```python
普通方法  两个条件是逻辑与的关系。
BookInfo.objects.filter( id__gt=3 , bread__gt=30 )

Q对象方法 要被查询的字段需要被Q()包含  &代表逻辑与
BookInfo.objects.filter( Q(id__gt=3) & Q(bread__gt=30) )
```

例：查询id大于3或者阅读量大于30的图书信息。

```python
| 是逻辑或  用它连接Q的条件。
BookInfo.objects.filter( Q(id__gt=3) | Q(bread__gt=30) )
```

例：查询id不等于3的图书信息。

```python
~ 不等于的意思，
BookInfo.objects.filter(~ Q(id=3) )
```

## 6.查询相关函数

- get:返回一个且只能有一条数据，返回值是一个对象，参数可以写查询条件。

- all:返回模型类对应表的所有数据，返回值是QuerySet.

- filter:返回满足套件的数据，返回值是QuerySet,参数可以写查询条件。

- exclude:返回不满足条件的数据，返回值是QuerySer，参数可以写查询条件。

- order_by:对查询结果进行排序返回值是QuerySet,参数中写排序的字段。

  

```
from django.db.models import F,Q,Count,Max,Min
```

- F对象：用于类属性之间进行比较。
- Q对象：用于条件之间的逻辑关系。



- aggregate:进行聚合操作，返回值是一个字典，进行聚合的时候，需要先导入聚合类。
- count:返回结果集中数据的目的，返回值是一个数字。



注意：

​	对一个QuerySet实例对象，可以据需调用上面的所有函数。

注意：

1. 通过模型类实现关联查询时，要查那个表中的数据，就需要通过那个类来查。
2. 写关联查询条件的时候，如果类中没有关系属性，条件需要对应类的名，如果类中有关系属性，直接写关系属性。

## 9.查询集

**all  、 filter 、 exclude 、 order_by 调用这些函数会产生查询集，QuerySet类对象可以继续调用上限所有函数。**

1. 惰性查询：只有在实际使用查询集中的数据的时候才会发生对数据的真正查询。
2. 缓存：当使用的是统计一个查询集的时候，第一次的时候就会发生实际数据库的查询，然后把结果缓存起来，之后在使用这个查询集的时候，使用的是缓存的结果。

**限制查询集：**

可以对一个查询集进行去下表或者切片操作来限制查询集的结果。

对一个查询集进行切片操作会产生一个新的查询集，下表不允许为负数。

取出查询集第一条数据的两种方式：



| 方式         | 说明                                                 |
| ------------ | ---------------------------------------------------- |
| b[0]         | 如果  b[0] 不存在，就会抛出一个 IndexError异常。     |
| b[0:1].get() | 如果 b[0:1].get() 不存在，就会抛出DoesNotExist异常。 |

exists:来判断一个查询集中是否有数据。 True False

## 10.抽象基类

**抽象基类在你将一些共同信息导入到多个其他模型的时候很有用。**

**你写你的基类，并在Meta类（元类）中设置abstract=True。该模型不用于生成任何数据库表。反而，当抽象基类用于其他模型的一个基类是，它的fields（字段）会被添加到那些子类中。**

## 11.url配置过程

- 在项目的urls 文件中包含具体应用的urls 文件，在具体应用的urls文件中包含具体url和视图的对应关系。
- url配置项是定义在一个叫 urlpatterns 的列表中，其中每一个元素就是一个配置项，每一个配置项都调用urlh函数。

## 12.属性

- path ：一个字符串，表示请求的页面的完整路径，不包含域名和部分参数。
- method  : 一个字符串，表示请求使用的HTTP方法，常用值包括 GET 、POST 。
  - 在浏览器中给出地址发请求采用get方式，如超链接。
  - 在浏览器中点击表单的提交按钮发起请求，如果表单的method设置为post则为post请求。
- encoding : 一个字符串，表示提交的数据编码方式。
  - 如果为None则表示使用浏览器的默认设置，一般为utf-8.
  - 这个属性是可写的，可以通过修改它来访问表单数据使用的编码，接下来对属性的任何访问将使用鑫的encoding值。
- GET ：QueryDict类型对象，类似与字典，包含get请求方式所有参数。
- POST：QueryDict类型对象，类似于字典，包含post请求方式的所有参数。
- FILES : 一个类似于字典的对象，包含所有上传文件。
- COOKIES ： 一个标准的Python字典，包含所有cookie，键和值都为字符串。
- session : 一个既可以读 又可以写的类似于字典的对象，表示当前的话，只当有Django 启用绘画的支持时才可使用，详情内容见 “状态保持”。
- 运行服务器，在浏览器中浏览首页，可以在浏览器“开发者工具”中看到下图：

## 13.cooie的特点：

1. 以键值对方式进行存储。

2. 通过浏览器访问一个网站时，会将浏览器存储的跟网站相关的所有cookie信息发送给网站的服务器。request.COOKIES

   （你去买烧饼，你去买烧饼，你只会把买少烧饼的单子给他 你肯定不会把卖豆浆的单子也起给他）

3. cookie 是基于域名安全的。

4. cookie是有过期时间的，如果不指定，默认关闭浏览器之后 cookie就会过期。

## 14.session的特点：

1. session是以键值对进行存储的。
2. session依赖于cookie。唯一的标识码保存在sessionid cookie 中。
   - 问：所有请求者的session 都会存储在服务器中，服务器如何区分请求者和session的数据对应关系呢？
   - 答：在使用session后，会在Cookie中存储一条sessionid的数据，每次请求时浏览器都会将这个数据发给服务器，服务器接收sessionid后，会根据这个值找到这个请求者的session.
   - 结果如果想使用session，浏览器必须支持cookie，否则就无法使用session了。
   - 存储session时，键与Cookie中的sessionid相同，值是开发人员设置的键值对信息进行了base64编码，过期时间有开发人员设置。
3. session 也是有过期时间的，如果不指定，默认就会两周过期。

## 15.cookie和session的应用场景

Cookie:

- 记住用户名。
- 保存在浏览器端。
- 对于安全性要求不高的数据可以使用cookie进行保存。

session:

- 记住用户的登录状态
- 保存在服务器端
- 对于安全性要求比较高的，比如用户银行卡等信息使用session进行保存。

## 16.HTML转义

什么是HTML转义？

通过模板上下文，传递给模板文件的数据里面含有，大于小于单引号双引号和and符号的话，他在显示的时候会进行一个转义。

应用场景：

后期做项目，编辑商品详情信息的时候通常是由后台管理员进行编辑，通常我们会某个字体设置一些格式，比如加粗，加标题，这部分你内容 保存在数据库就是保存html的内容。

在模板上下文中的html标记默认是会被转义的。

## 17.csrf攻击

跨站伪造

1. 在进行网站开发的时候，有些页面是用户登陆之后才可以访问的，假如用户访问了这个地址，需要进行登陆的判断，如果用户登陆了话，可以进行后续的操作，如果没有登陆，跳转到登陆页面。

## 18.django防止csrf的方式：

1. 默认打开csrf中间件。

2. 表单post提交数据的时候加上：

   ```jinja2
   {% csrf token %}  标签
   ```

# 